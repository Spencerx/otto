#   otto.fmt
#
#   Written:    97/02/16  iMatix <otto@imatix.com>
#   Revised:    99/07/05  Pieter Hintjens <ph@imatix.com>
#
#   Series of Perl actions that create the various command blocks
#   required by each system.  Each subroutine can take intelligent
#   action to generate the necessary text.
#
#   This file is externalised from otto so that it can be customised
#   without changing otto, and made local for specific projects.
#

#######  INIT - output to initialise processing

sub init_unix {
    #  File extensions for specific file types
    $ext {"\$LIB", "unix"} = ".a";
    $ext {"\$EXE", "unix"} = "";
    $ext {"\$OBJ", "unix"} = ".o";
}

sub init_msdos {
    #  File extensions for specific file types
    $ext {"\$LIB", "msdos"} = ".lib";
    $ext {"\$EXE", "msdos"} = ".exe";
    $ext {"\$OBJ", "msdos"} = ".obj";
    $label_msdos = 0;
}

sub init_vms {
    #  File extensions for specific file types
    $ext {"\$LIB", "vms"} = ".olb";
    $ext {"\$EXE", "vms"} = ".exe";
    $ext {"\$OBJ", "vms"} = ".obj";
    $label_vms = 0;
}

sub init_os2 {
    #  File extensions for specific file types
    $ext {"\$LIB", "os2"} = ".a";
    $ext {"\$EXE", "os2"} = ".exe";
    $ext {"\$OBJ", "os2"} = ".o";
    $label_os2 = 0;
}

sub init_makefile {
    #  File extensions for specific file types
    #  These are defined via Makefile substitution so we can change them,
    #  by just editing the makefile header.
    $ext {"\$LIB", "makefile"} = ".\$(LIB)";
    $ext {"\$EXE", "makefile"} = ".\$(EXE)";
    $ext {"\$OBJ", "makefile"} = ".\$(OBJ)";

}


#######  HEADER - output when we create a new script file

sub header_unix {
    print <<".";
#! /bin/sh
#
#   Build script for $title, for generic UNIX.
#   Requires the iMatix 'c' shell script.
#
#   Generated by Otto $version from $script on $date, $time
#   For more info see Otto documentation at http://www.imatix.com.
#   Bug reports & questions to <ph\@imatix.com>
#   ---------------------------------------------------------------
#
test -f c && chmod +x c
.
}

sub header_msdos {
    print <<".";
\@echo off
:-
:-  Build script for $title, for generic MS-DOS.
:-  Requires the iMatix 'c' batch file.
:-
:-  Generated by Otto $version from $script on $date, $time
:-  For more info see Otto documentation at http://www.imatix.com.
:-  Bug reports & questions to <ph\@imatix.com>
:-  ---------------------------------------------------------------
:-
.
}

sub header_vms {
    print <<".";
\$ SET NOVERIFY
\$!
\$!  Build script for $title, for Digital OpenVMS.
\$!
\$!  Generated by Otto $version from $script on $date, $time
\$!  For more info see Otto documentation at http://www.imatix.com.
\$!  Bug reports & questions to <ph\@imatix.com>
\$!  ---------------------------------------------------------------
\$!
.
}

sub header_os2 {
    print <<".";
/*
 *  Build script for $title, for OS/2.
 *  Requires the iMatix 'c.cmd' script.
 *
 *  Generated by Otto $version from $script on $date, $time
 *  For more info see Otto documentation at http://www.imatix.com.
 *  Bug reports & questions to <ewen\@imatix.com>
 *  ---------------------------------------------------------------
 */
'\@echo off'

/* Configuration options ------------------------------------------ 
 *
 * The actual programs use to compile, compile and archive, and 
 * link programs can be changed by editing the subroutines
 * CompileToObj, CompileToLib, and LinkProgram, at the bottom of
 * this script.  REXX doesn't support variable substitution in
 * the name of the called routine, so they cannot be defined here.
 */

.
}

sub header_makefile {
    #
    #   We use @sourcefiles_makefile to track the source files which we
    #   compile, so that we can write out a Makefile variable which defines
    #   them all, which can then be used with something like makedepend.
    #
    #   We reset it here so that it contains only the things for each file.
    #
    undef @sourcefiles_makefile;

    #   And we need to track the libraries, and programs that we build
    #   in this file, so we can write out the final rule.
    undef @targets_makefile;

    #   But we have to track the libraries separately as well so that
    #   we can make the programs depend on them.
    undef @libraries_makefile;

    print <<".";
#
#   UNIX & OS/2 Makefile for $title
#   Requires the iMatix 'c' shell script/command script.
#
#   Generated by Otto $version from $script on $date, $time
#   For more info see Otto documentation at http://www.imatix.com.
#   Bug reports & questions to <ewen\@imatix.com>
#   ---------------------------------------------------------------
#

#   Default values for library, executable and object extensions
#   For most unix systems EXE should be empty; OS/2 (with EMX) can use this
#   setting if gcc is given the "-Zexe" command ('c.cmd' uses -Zexe).
#
LIB     = .a
EXE     =
OBJ     = .o

#   Configuration options
#
#   The makefile is configured to use the iMatix "c" script to compile
#   link, and archive, to enhance portability.  That script contains all
#   compile, link, and archive options.
#
C       = c
LR      = lr
MAKEDEP = makedepend

#   Libraries -- these are the ones that should always cause a relink if they
#   are updated (the executables in a makefile will also depend on any
#   libraries that are built in that Makefile).
#
LIBRARIES = libsfl\$(LIB)

#   Implicit rules
#

#   Reset the suffixes that will be considered to just our own list.
#
#   Unix make programs use the .SUFFIXES psuedo rule for this

.SUFFIXES:
.SUFFIXES: \$(EXE) \$(LIB) \$(OBJ) .c .d .i .l

#   Objects depend on source files with the same name; and are compiled
#   with the iMatix c script without any arguments.
#
.
    #  We use suffix rules here to enhance portability.
    #
    print "\.c\$(OBJ):\n";
    print "\t\$(C) -q -c \$<\n\n";

        print <<".";
#   And .c files _do_not_ depend on .l files (.l files are Libero files,
#   not lex input files as the default rules think).
#
#   The semicolon is required so GNU make will accept the rule as an override.
#
.
        print ".l.c: ;\n\n";

    print <<".";
#   But .d and .i files do depend on .l files (these are the ones that Libero
#   will build).
#
.

    print ".l.d:\n";
    print "\t\$(LR) \$<\n\n";

    print ".l.i:\n";
    print "\t\$(LR) \$<\n\n";

    print <<"."
#
#   Default rule -- all depends on everything.
#   We do this so that we can define the rule at the end.
#
all: everything

#---------------------------------------------------------------------------
.
}


sub header_msmake {
    undef @sourcefiles_makefile_ms;
    undef @targets_makefile_ms;
    undef @libraries_makefile_ms;
    print <<".";
#
#   MS-DOS makefile for $title; compatible with nmake.
#
#   Generated by Otto $version from $script on $date, $time
#   For more info see Otto documentation at http://www.imatix.com.
#   Bug reports & questions to <ewen\@imatix.com>
#   ---------------------------------------------------------------
#

#   Default values for library, executable and object extensions.
#
LIB     = .lib
EXE     = .exe
OBJ     = .obj

#   Configuration options
#
#   The makefile is configured to use the iMatix "c" batch file to compile
#   link, and archive, to enhance portability.  That batch file contains all
#   compile, link, and archive options.
#
C       = c
LR      = lr
MAKEDEP = makedepend

#   Libraries -- these are the ones that should always cause a relink if they
#   are updated (the executables in a makefile will also depend on any
#   libraries that are built in that Makefile).
#
LIBRARIES =

#   Implicit rules
#

#   Reset the suffixes that will be considered to just our own list.
#
#   Unix make programs use the .SUFFIXES psuedo rule for this

.SUFFIXES:
.SUFFIXES: \$(EXE) \$(LIB) \$(OBJ) .c .d .i .l

#   Objects depend on source files with the same name; and are compiled
#   with the iMatix c script without any arguments.
#
.
    #  We use suffix rules here to enhance portability.
    #
    print "\.c\$(OBJ):\n";
    print "\t\$(C) \$<\n\n";

    print <<".";
#   .d and .i files do depend on .l files (these are the ones that Libero
#   will build).
#
.

    print ".l.d:\n";
    print "\t\$(LR) \$<\n\n";

    print ".l.i:\n";
    print "\t\$(LR) \$<\n\n";

    print <<"."
#
#   Default rule -- all depends on everything.
#   We do this so that we can define the rule at the end.
#
all: everything

#---------------------------------------------------------------------------
.
}


#######  FOOTER - output when we end a script file

sub footer_unix {
    print <<".";

# -- end script without errors
exit 0
.
}

sub footer_msdos {
    print <<".";

:exit
:-- end script
.
}

sub footer_vms {
    print <<".";
\$ purge/noconf
\$
\$! -- end script
.
}

sub footer_os2 {
    print <<".";

exit 0
/* End script */

/* Utility subroutines ---------------------------------------------------- */

/* AssertFileExists <file>
 *
 * Checks to see if the specified file (argument 1) exists.  If it does the
 * subroutine returns.  If it doesn't, the subroutine displays an error
 * message, and exits the whole script.
 */

AssertFileExists:
fullpath = stream(ARG(1), 'C', 'QUERY EXISTS')
IF fullpath = "" THEN
DO
  SAY ARG(1) "missing -- aborting"
  exit 1
END

return

/* CompileToLib <source> <library>
 *
 * This is a stub routine to sort things out for compiling to a library.
 * We need to set CCLIBNAME to the name of the library, then call the 
 * 'c' script, then reset CCLIBNAME.  
 */

CompileToLib:

PARSE ARG SOURCE LIBRARY

oldenv  = VALUE('CCLIBNAME', LIBRARY, 'OS2ENVIRONMENT')
CALL c              SOURCE
CALL c '-r' LIBRARY SOURCE
LIBRARY = VALUE('CCLIBNAME', oldenv,  'OS2ENVIRONMENT')

return

/* CompileToObj <source>
 *
 * This is a stub routine to sort things out for compiling to an object.
 * We need to clear CCLIBNAME, then call c script with the "-c" parameter
 * to indicate compile only, and then reset CCLIBNAME again.
 */

CompileToObj:

SOURCE = ARG(1)

oldenv  = VALUE('CCLIBNAME', '',      'OS2ENVIRONMENT')
CALL c '-c' SOURCE
LIBRARY = VALUE('CCLIBNAME', oldenv,  'OS2ENVIRONMENT')

return

/* LinkProgram <name>
 *
 * This is a stub routine to sort out the things required for linking.
 * We call the c script with the "-L" parameter to link only.
 */

LinkProgram:

PROGRAM = ARG(1)
CALL c '-L' PROGRAM

return

/* End of Utility Subroutines (remaining functionality now in c.cmd) ------ */
.
}

sub footer_makefile {
#
# This defines the everything target, which depends on the libraries and
# executables that we create.  It is effectively our "all" rule, but is here
# at the end when we know all the bits we need to make.
#
# But first, if the library hasn't finished off, we should do that first.
#
  if ($oldlibrary)
  {
    if (defined ($librarydependencies_makefile [0]))
    {
      local($libname) = $oldlibrary;
      $libname =~ tr/a-z/A-Z/;
      print "$libname", "_LIST = ",
            join(' ', @librarydependencies_makefile), "\n\n";

      print "# Force the library to be dependant on its bits.\n";
      print "#\n";
      print "$oldlibrary\$(LIB): \$($libname", "_LIST)", "\n\n";
    }
    $oldlibrary = "";
  }

  print "everything: ", join(' ', @targets_makefile), "\n\n";

  # Finally output a list of the sources that we have seen along the way
  # so that it can be used with make depend.
  print "SRCS = ", join(' ', @sourcefiles_makefile), "\n\n";

  # Oh, and we might as well put in the make depend rule as well.
  # Leave it to be manually run for now, as required.
  #
  print "# Build dependencies, using makedepend. \n";
  print "#\n";
  print "# Yes, this rule is very ugly.  It's an attempt to be portable\n";
  print "# about the way that makedepend is called, including picking up\n";
  print "# the flags to call the compiler with for makedepend to use.\n";
  print "#\n";
  print "# See otto.fmt for details.\n";
  print "#\n";
  print "depend:\n";

  # What we do here is:
  # Assemble the command to run in bits, from the makedepend call, and the
  # flags for the compiler (obtained from c -C, with the first two arguments
  # (compiler name, and "-c") stripped off, and finally the list of source
  # files to use.
  #
  # Then massage that into a single line with perl, in a .cmd file (for
  # OS/2; unix doesn't care), make it executable (for unix; OS/2 doesn't
  # care), and then run it and clean up afterwards.
  #
  # Note: the print; print ' '; bit is there so that we don't have to deal
  # with the interaction between perl now, make, and perl later reguarding
  # dollar signs.
  #
  # Note: we use double quotes around the perl command line arguments,
  # because that is all that perl under OS/2 can understand.  Since we
  # feed this double quoted string to sh, it interpolates our backslashes,
  # so we have to double them. But the perl we are running now also
  # interpolates them, so we actually need _four_ of them!
  #
  print "\trm -f temp1111.cmd temp1111.xxx\n";
  print "\techo \$(MAKEDEP) -- >temp1111.xxx\n";
  print "\t\$(C) -C | perl -ne \"\@a = split; shift(\@a); shift(\@a); print join(' ', \@a), qq(\\\\n);\" >>temp1111.xxx\n";
  print "\techo -- \$(SRCS) >>temp1111.xxx\n";
  print "\tperl -e \"while(<>) {chop; print; print ' ';} print qq(\\\\n);\" temp1111.xxx >temp1111.cmd\n";
  print "\tchmod +x temp1111.cmd\n";
  print "\tsh temp1111.cmd\n";
# print "\trm -f temp1111.cmd temp1111.xxx\n";

}

sub footer_msmake {
#
# This defines the everything target, which depends on the libraries and
# executables that we create.  It is effectively our "all" rule, but is here
# at the end when we know all the bits we need to make.
#
# But first, if the library hasn't finished off, we should do that first.
#
  if ($oldlibrary_ms)
  {
    if (defined ($librarydependencies_makefile_ms [0]))
    {
      local ($libname) = $oldlibrary_ms;
      $libname =~ tr/a-z/A-Z/;
      print "$libname", "_LIST = ",
            join(' ', @librarydependencies_makefile_ms), "\n\n";

      print "# Force the library to be dependant on its bits.\n";
      print "#\n";
      print "$oldlibrary_ms\$(LIB): \$($libname", "_LIST)", "\n\n";
    }
    $oldlibrary_ms = "";
  }

  print "everything: ", join(' ', @targets_makefile_ms), "\n\n";

  # Finally output a list of the sources that we have seen along the way
  # so that it can be used with make depend.
  print "SRCS = ", join(' ', @sourcefiles_makefile_ms), "\n\n";
}


#######  TRACE - output trace of the $action_line

sub trace_unix {
    print <<".";

#-  $action_line
.
}

sub trace_msdos {
    print <<".";

:-  $action_line
.
}

sub trace_vms {
    print <<".";
\$
\$!  $action_line
.
}

sub trace_os2 {
    print <<".";

/* $action_line */
.
}

sub trace_makefile {
#
# There's not really anything sensible a makefile can do here, so we don't
# do anything.
#
}


#######  APPEND - append $source to $target

sub append_unix {
    print <<".";
cat $source >> $target
.
}

sub append_msdos {
    print <<".";
type $source >> $target
.
}

sub append_vms {
    print <<".";
\$ append $source $target
.
}

sub append_os2 {
    print <<".";
\'type $source >> $target\'
.
}

sub append_makefile {
#
# What we should be doing here is collecting up a list of things that
# get appended together; then we can make the generated file depend on
# all the components -- and use the generated shell/command scripts 
# to generate the whole set.
#
}


#######  CALL - call $subroutine with $arguments

sub call_unix {
    print <<".";
test -f $subroutine && chmod +x $subroutine
./$subroutine $arguments
.
}

sub call_msdos {
    print <<".";
call $subroutine $arguments
.
}

sub call_vms {
    print <<".";
\$ \@$subroutine.txt $arguments
.
}

sub call_os2 {
    print <<".";
call $subroutine.cmd $arguments
.
}

sub call_makefile {
#
# I haven't figured out what to do with this yet.
#
}


#######  COMMENT - output the script comment in $_

sub comment_unix {
    print <<".";
#-  $_
.
}

sub comment_msdos {
    print <<".";
:-  $_
.
}

sub comment_vms {
    print <<".";
\$!  $_
.
}

sub comment_os2 {
    print <<".";
/*  $_ */
.
}

sub comment_makefile {
#
# I haven't figured out what to do with this yet.
#
}

#######  COMPILE - compile $program source file, insert into $library
#        if $library is defined.

sub compile_unix {
    print <<".";
./c $program
test \$? -ne 0 && exit 1
.
    print <<"."
./c -r $library $program
rm $program.o
.
        if $library;
}

sub compile_msdos {
    print <<".";
call c $program
if not exist $program.obj goto exit
.
    print <<"."
call c -r $library.lib $program
.
        if $library;
}

sub compile_vms {
    print <<".";
\$ write sys\$output "Compiling $program..."
\$ cc/define=debug $program
.
    print <<"."
\$ lib $library $program
.
        if $library;
}

sub compile_os2 {
if ($library)
  {
    print <<".";
CALL CompileToLib \'$program\' \'$library\'
.
  }
else
  {
    print <<".";
CALL CompileToObj \'$program\'
.
  }
}

sub compile_makefile {
  # If there is an active library then to do the compile, we make the
  # library object depend on the external object, and add the object
  # to the library.
  #
  # We rely on an implict rule to make the object depend on the source.

  if ($library)
  {
    print "$library\$(LIB)($program\$(OBJ)): $program\$(OBJ)\n";
    print "\t\$(C) -q -r $library\$(LIB) $program\$(OBJ)\n\n";

    push(@librarydependencies_makefile, "$library\$(LIB)($program\$(OBJ))");
  }

  # Either way, though, it's another source file for our collection.
  push(@sourcefiles_makefile, "$program.c");
}


sub compile_msmake {
  # If there is an active library then to do the compile, we make the
  # library object depend on the external object, and add the object
  # to the library.
  #
  # We rely on an implict rule to make the object depend on the source.

  if ($library)
  {
    print "$library\$(LIB)($program\$(OBJ)): $program\$(OBJ)\n";
    print "\t\$(C) -r $library\$(LIB) $program\$(OBJ)\n\n";

    push(@librarydependencies_makefile_ms, "$library\$(LIB)($program\$(OBJ))");
  }

  # Either way, though, it's another source file for our collection.
  push(@sourcefiles_makefile_ms, "$program.c");
}


#######  COPY - copy/overwrite $source to $target with no confirmation

sub copy_unix {
    print <<".";
cp $source$ext1_value $target$ext2_value
.
}

sub copy_msdos {
    print <<".";
if exist $target$ext2_value del $target$ext2_value
copy $source$ext1_value $target$ext2_value
.
}

sub copy_vms {
    print <<".";
\$ copy $source$ext1_value $target$ext2_value
.
}

sub copy_os2 {
    print <<".";
copy $source$ext1_value $target$ext2_value
.
}

sub copy_makefile {
#
# I haven't figured out what to do with this yet.
#
}


#######  DELETE - delete $filename without confirmation

sub delete_unix {
    print <<".";
rm -f $filename$ext1_value
.
}

sub delete_msdos {
    print <<".";
if exist $filename$ext1_value del $filename$ext1_value
.
}

sub delete_vms {
    $label_vms++;
    print <<".";
\$ on warning then goto nf_$label_vms
\$ uic = f\$file_attributes("$filename$ext1_value","uic")
\$ del/noconf $filename$ext1_value;
\$ nf_$label_vms:
\$ on warning then exit
.
}

sub delete_os2 {
    print <<".";
\'if exist $filename$ext1_value del $filename$ext1_value >nul\'
.
}

sub delete_makefile {
#
# I haven't figured out what to do with this yet.
#
}

#######  ECHO - echo text in $_ to console

sub echo_unix {
    print <<".";
echo '$_'
.
}

sub echo_msdos {
    print <<".";
echo $_
.
}

sub echo_vms {
    print <<".";
\$ write sys\$output "$_"
.
}

sub echo_os2 {
    print <<".";
SAY "$_"
.
}

sub echo_makefile {
#
# I haven't figured out what to do with this yet.
#
}


#######  INSTALL - install $filename

sub install_unix {
    print <<".";
echo Installing $filename$ext1_value...
cp $filename$ext1_value install_dir
.
}

sub install_msdos {
    print <<".";
echo Installing $filename$ext1_value...
copy $filename$ext1_value install.dir
.
}

sub install_vms {
    print <<".";
\$ write sys\$output "Installing $filename$ext1_value..."
\$ copy $filename$ext1_value [.install]
.
}

sub install_os2 {
    print <<".";
SAY "Installing $filename$ext1_value..."
copy $filename$ext1_value install.dir
.
}

sub install_makefile {
#
# I haven't figured out what to do with this yet.
#
}


#######  LIBRARY - define or undefine $library for compile commands

sub library_unix {
    #   Define library symbol, so that the c compile script uses it
    if ($library) {
        print <<".";
CCLIBNAME=$library
export CCLIBNAME
.
    }
}

sub library_msdos {
    #   Nothing required; library is created when first used
}

sub library_vms {
    $label_vms++;
    print <<"."
\$ on warning then goto nf_$label_vms
\$ uic = f\$file_attributes("$library.olb","uic")
\$ goto ok_$label_vms
\$ nf_$label_vms:
\$ lib/create $library
\$ ok_$label_vms:
\$ on warning then exit
.
        if $library;
}

sub library_os2 {
    # Nothing required; library is created when first used
}

sub library_makefile {
# To handle building libraries, we make use of special syntax supported
# by, at least, GNU Make.  That is that libraryname(objectname) refers to
# the object inside the archive, so we can make that depend on the external
# object file.
#
# But we do have to track the files which make up the library, so that we
# can write out a rule to make them all depend on the default.
#
# We store that in  @librarydependencies_makefile.
#
  if ($oldlibrary)
  {
    if (defined ($librarydependencies_makefile [0]))
    {
      local($libname) = $oldlibrary;
      $libname =~ tr/a-z/A-Z/;
      print "$libname", "_LIST = ",
            join(' ', @librarydependencies_makefile), "\n\n";

      print "# Force the library to be dependant on its bits.\n";
      print "#\n";
      print "$oldlibrary\$(LIB): \$($libname", "_LIST)", "\n\n";

    }
  }
  $oldlibrary = $library;
  undef @librarydependencies_makefile;
  local($libname) = $library;
  $libname =~ tr/a-z/A-Z/;
  push (@targets_makefile,   "$library\$(LIB)") if ($library);
  push (@libraries_makefile, "$library\$(LIB)") if ($library);
}

sub library_msmake {
# To handle building libraries, we make use of special syntax supported
# by, at least, GNU Make.  That is that libraryname(objectname) refers to
# the object inside the archive, so we can make that depend on the external
# object file.
#
# But we do have to track the files which make up the library, so that we
# can write out a rule to make them all depend on the default.
#
# We store that in  @librarydependencies_makefile.
#
  if ($oldlibrary_ms)
  {
    if (defined ($librarydependencies_makefile_ms [0]))
    {
      local($libname) = $oldlibrary_ms;
      $libname =~ tr/a-z/A-Z/;
      print "$libname", "_LIST = ",
            join(' ', @librarydependencies_makefile_ms), "\n\n";

      print "# Force the library to be dependant on its bits.\n";
      print "#\n";
      print "$oldlibrary_ms\$(LIB): \$($libname", "_LIST)", "\n\n";

    }
  }
  $oldlibrary_ms = $library;
  undef @librarydependencies_makefile_ms;
  local($libname) = $library;
  $libname =~ tr/a-z/A-Z/;
  push (@targets_makefile_ms,   "$library\$(LIB)") if ($library);
  push (@libraries_makefile_ms, "$library\$(LIB)") if ($library);
}


#######  LINK - link specified $program into executable

sub link_unix {
    print <<".";
./c -L $program
.
}

sub link_msdos {
    print <<".";
call c -L $program
.
}

sub link_vms {
    print <<".";
\$! This link command won't work if there are other libraries
\$! to include...  Needs more work.
\$ link $program,libsfl/lib
.
}

sub link_os2 {
    print <<".";
CALL LinkProgram \'$program\'
.
}

sub link_makefile {
#
# To link we make the executable depend on an object of the same name,
# and the action to be $(C) -L.  The executables are also made to
# depend on all the libraries we've built.
#
  print "$program\$(EXE): $program\$(OBJ) \$(LIBRARIES) ";
  print join(' ', @libraries_makefile) if defined($libraries_makefile[0]);
  print "\n";

  print "\t\$(C) -q -L $program\n\n";

# And that gives us another target to build from the default rule.
  push(@targets_makefile, "$program\$(EXE)");
}

sub link_msmake {
#
# To link we make the executable depend on an object of the same name,
# and the action to be $(C) -L.  The executables are also made to
# depend on all the libraries we've built.
#
  print "$program\$(EXE): $program\$(OBJ) \$(LIBRARIES) ";
  print join(' ', @libraries_makefile_ms) if defined($libraries_makefile_ms[0]);
  print "\n";

  print "\t\$(C) -L $program\n\n";

# And that gives us another target to build from the default rule.
  push (@targets_makefile_ms, "$program\$(EXE)");
}


#######  PAUSE - wait for user input

sub pause_unix {
    print <<".";
if test "\$1" = ""; then read pause; fi
.
}

sub pause_msdos {
    print <<".";
if .%1==. pause >nul
.
}

sub pause_vms {
    print <<".";
\$ read sys\$input response /prompt=""
.
}

sub pause_os2 {
    print <<".";
'if .%1==. pause >nul'
.
}

sub pause_makefile {
#
# Makefiles don't pause -- we assume that the user knows what they are doing.
#
}

#######  RENAME - rename/overwrite $source to $target with no confirmation

sub rename_unix {
    print <<".";
mv $source$ext1_value $target$ext2_value
.
}

sub rename_msdos {
    print <<".";
if exist $target$ext2_value del $target$ext2_value
rename $source$ext1_value $target$ext2_value
.
}

sub rename_vms {
    print <<".";
\$ ren $source$ext1_value $target$ext2_value
.
}

sub rename_os2 {
    print <<".";
move $source$ext1_value $target$ext2_value
.
}

sub rename_makefile {
#
# I haven't figured out what to do with this yet.
#
}


#######  REQUIRE - abort if specified $filename is not present

sub require_unix {
    if ($ext1_value eq ".a") {
        print <<".";
if test ! -f $filename.a -a ! -f /usr/lib/$filename.a ; then
    echo $filename$ext1_value missing - aborting
    exit
fi
.
    }
    elsif ($ext1_value eq ".h") {
        print <<".";
if test ! -f $filename.h -a ! -f /usr/include/$filename.h ; then
    echo $filename$ext1_value missing - aborting
    exit
fi
.
    }
    else {
        print <<".";
if test ! -f $filename$ext1_value; then
    echo $filename$ext1_value missing - aborting
    exit
fi
.
    }
}

sub require_msdos {
    $label_msdos++;
    print "if exist $filename$ext1_value goto end_$label_msdos\n";
    if ($ext1_value eq ".lib") {
        print "if exist \\usr\\lib\\$filename.lib goto end_$label_msdos\n";
    }
    elsif ($ext1_value eq ".h") {
        print "if exist \\usr\\include\\$filename.h goto end_$label_msdos\n";
    }
    print <<".";
    echo $filename$ext1_value missing - aborting
    goto exit
:end_$label_msdos
.
}

sub require_vms {
    $label_vms++;
    print <<".";
\$ on warning then goto nf_$label_vms
\$ uic = f\$file_attributes("$filename$ext1_value","uic")
\$ goto ok_$label_vms
\$ nf_$label_vms:
\$ write sys\$output "$filename$ext1_value missing - aborting"
\$ exit
\$ ok_$label_vms:
\$ on warning then exit
.
}

sub require_os2 {
    print <<".";
CALL AssertFileExists \'$filename$ext1_value\'
.
}

sub require_makefile {
#
# Makefiles handle their own dependencies so we do not do anything here.
#
}

#######  SYSTEM - output system-specific command in $_

sub system_unix {
    print <<".";
$_
.
}

sub system_msdos {
    print <<".";
$_
.
}

sub system_vms {
    print <<".";
\$ $_
.
}

sub system_os2 {
    print <<".";
$_
.
}

sub system_makefile {
#
# I haven't figured out what to do with this yet.
#
}

1;                                      #   Return a true value

